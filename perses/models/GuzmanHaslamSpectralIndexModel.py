import numpy as np
import matplotlib.pyplot as plot
from distpy import GaussianDistribution
import os
import healpy

class GuzmanHaslamSpectralIndexModel(object):
	"""
	Class to create a model for the galactic spectral index
	(for a power-law like galaxy or emission component)
	using maps generated by the interpolating between the 
	45 MHz Guzman map and the 408 MHz Haslam map. The default
	nside used in this case is chosen always to be 128, as that
	is the error resolution of the master spectral index map.
	"""

	@property
	def nside(self):
		"""
		"""
		if not hasattr(self, '_nside'):
			self._nside = 128
		return self._nside

	@nside.setter
	def nside(self, value):
		self._nside = value
	
	@property
	def num_channels(self):
		return healpy.pixelfunc.nside2npix(self.nside)
	
	@property
	def parameters(self):
		"""
		The seed parameter ensures a particular realization of each
		distribution to make each map can be replicated. It is a random
		integer.
		"""
		if not hasattr(self, '_parameters'):
			self._parameters = ['seed']
		return self._parameters

	@property
	def error(self):
		"""
		The default choice of 0.01 is taken from the Guzman 2011 paper, which
		estimates the maximum error of their map's average spectral index
		(at a given galactic location) to be approximately 0.03 from the true
		value, which is determined by comparisons with other maps and a large
		literature survey fit. This is thus the standard deviation.
		"""
		if not hasattr(self, '_error'):
			self._error = 0.01
		return self._error

	@error.setter
	def error(self, value):
		self._error = value

	@property
	def master_spectral_index(self):
		"""
		Master spectral index map taken by fitting a power law between the
		45 MHz map of Guzman and the 408 MHz map of Haslam and then using the
		best-fitting spectral index at each pixel as the master map.
		"""
		if not hasattr(self, '_master_spectral_index'):
			self._master_spectral_index = np.loadtxt('{!s}/input/GH'.format(os.environ['PERSES']) + 
				'/Interpolated_Guzman_Haslam_Spectral_Index_128nside')
			self._master_spectral_index = healpy.pixelfunc.ud_grade(self._master_spectral_index, self.nside)
		return self._master_spectral_index

	def __call__(self, pars, noise_smoothed=False, kernel_FWHM=7.):
		"""
		noise_smoothed: if True, then the noise offset realization is first smoothed
						using the healpy 'smoothing' function with the given
						kernel_FWHM.
		kernel_FWHM: The FWHM of the smoothing kernel, in degrees. Default is 7 deg.
		"""
		seed = pars[0]
		npix = healpy.pixelfunc.nside2npix(self.nside)		
		offset_distribution = GaussianDistribution(0, (self.error)**2)
		noise_offset = offset_distribution.draw(npix, random=np.random.RandomState(seed=seed))
		if noise_smoothed:
			FWHM_in_rad = (kernel_FWHM*np.pi) / 180.
			noise_offset = healpy.sphtfunc.smoothing(noise_offset, fwhm = FWHM_in_rad)
		spectral_index = self.master_spectral_index + noise_offset
		return spectral_index
