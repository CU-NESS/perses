"""

test_ideal_beam.py

Author: Keith Tauscher
Affiliation: University of Colorado at Boulder
Created on: Sun Dec 18 13:16 MDT 2015
"""

import numpy as np
import healpy as hp
from scipy.special import sph_harm
import matplotlib.pyplot as pl
from perses.beam.total_power.FourierMeasuredBeam\
    import FourierMeasuredBeam as Beam
import time


alm = np.zeros((2, 21), dtype=np.dtype(np.cfloat)) # 21 alm's for lmax=5
alm[:,0] = 10 # give both frequencies an offset so there are no
              # negative pixels caused by the the higher harmonics
alm[0,6] = -1.j # alm[6] is the l=1 m=1 term when lmax=5
alm[1,6] = -2.j
# a11=-1 should yield sqrt(3)/(2pi) * sin(theta)*cos(phi)
frequencies = np.array([1.,2.])
beam = Beam(beam_mode='spherical harmonic', beam_data=(frequencies, alm))

# testing the exception thrown if unworkable frequency is given to get_maps
try:
    map_fail_test = beam.get_maps(0., pointing=(90., 0.), lmax=5)
    assert False
    # try catch block can only be executed if map_fail_test throws exception
except NotImplementedError:
    print('When an unworkable frequency was given, the correct exception ' +\
        'was raised.')


# testing the beam_mode=='spherical harmonic' case
t0 = time.time()
map_pass_test = beam.get_maps(1, (90., 0.), lmax=5)
hp.mollview(map_pass_test)
print('Generated a map from an alm with lmax=5 in {:.5g} s'.format(\
    time.time() - t0))
pl.title('Map generated by l=1 |m|=1 terms + a constant', size='xx-large')

# testing beam_mode
frequencies = np.arange(1.,4.)
numfreqs = len(frequencies)
thetas = np.arange(0., 180.5, 1.)
phis = np.arange(0.,360.,1.)

# generating synthetic beam data using spherical harmonics
t0 = time.time()
pattern_data = np.ndarray((numfreqs, len(thetas), len(phis)))

def angular_dependence(theta, phi):
    return 10.*sph_harm(0,0,phi,theta) + (-1.+1.j)*sph_harm(1, 1, phi, theta)+\
        (1.+1.j)*sph_harm(-1, 1, phi, theta)

for itheta in range(len(thetas)):
    theta = np.radians(thetas[itheta])
    for iphi in range(len(phis)):
        phi = np.radians(phis[iphi])
        for ifreq in range(len(frequencies)):
            freq = frequencies[ifreq]
            # generate beam data
            pattern_data[ifreq,itheta,iphi] = freq *\
                angular_dependence(theta, phi)

print(('Created synthetic data in 1 deg increments for 3 frequencies in ' +\
    '{!s} s').format(time.time() - t0))


# testing 
t0 = time.time()
data = (frequencies, thetas, phis, pattern_data)
data_beam = Beam(beam_mode='angular', beam_data=data, lmax=10)
data_beam_maps = data_beam.get_maps(np.arange(1.,4.), pointing=(90,0), lmax=10)
hp.mollview(data_beam_maps[0,:])
pl.title('First test beam given by direct angular data', size='xx-large')
hp.mollview(data_beam_maps[1,:])
pl.title('Second test beam given by direct angular data', size='xx-large')
hp.mollview(data_beam_maps[2,:])
pl.title('Third test beam given by direct angular data', size='xx-large')
print(('Found alm to lmax=10 for three frequencies and generated three ' +\
    'maps in {!s} s').format(time.time() - t0))


# testing whether the alm's are as expected from the input data
# given in the angular_dependence function defined above
t0 = time.time()
for ifreq in range(len(frequencies)):
    freq = frequencies[ifreq]
    alm_predicted = np.zeros(66., dtype=np.dtype(np.cfloat))
    assert np.isclose(data_beam.alm[ifreq,11]/data_beam.alm[ifreq,0],\
        (-0.1+0.1j), rtol=0, atol=2e-4)
    stored_alm0 = data_beam.alm[ifreq,0]
    data_beam.alm[ifreq,0] = 0 # setting alm directly is not a good idea.
    data_beam.alm[ifreq,11] = 0 # Here, it is done very carefully
    # now that known coefficients have been set to 0, the alm should be 0
    # but, 1 deg resolution leads to some elements that are about 5000 times
    # smaller than the largest coefficient (l=0,m=0 component) 
    assert np.allclose(data_beam.alm[ifreq,:] / stored_alm0,\
        np.zeros_like(data_beam.alm[ifreq,:]), rtol=0, atol=2e-4)
    print("{}/3 alm's are as expected".format(ifreq + 1))

pl.show()

