"""
File: perses/simulations/DriftscanSetCreator.py
Author: Keith Tauscher
Date: 5 Mar 2018

Description: File containing class which creates sets of foreground curves
             generated through a zenith pointing driftscan at an Earth-based
             observatory described by GroundObservatory objects.
"""
import os, time, h5py
import numpy as np
from ..util import bool_types, sequence_types
from .GroundObservatory import GroundObservatory
try:
    # this runs with no issues in python 2 but raises error in python 3
    basestring
except:
    # this try/except allows for python 2/3 compatible string type checking
    basestring = str

class DriftscanSetCreator(object):
    """
    Class which creates sets of foreground curves generated through a zenith
    pointing driftscan at an Earth-based observatory described by
    GroundObservatory objects.
    """
    @property
    def verbose(self):
        """
        Property storing a boolean which determines whether or not a message is
        printed after each convolution (i.e. pair of beam+maps).
        """
        if not hasattr(self, '_verbose'):
            raise AttributeError("verbose referenced before it was set.")
        return self._verbose
    
    @verbose.setter
    def verbose(self, value):
        """
        Setter for the boolean which determines whether or not a message is
        printed after each convolution (i.e. pair of beam+maps).
        
        value: True or False
        """
        if type(value) in bool_types:
            self._verbose = value
        else:
            raise TypeError("verbose was set to a non-bool.")
    
    @property
    def frequencies(self):
        """
        Property storing the frequency values to which the data applies.
        """
        if not hasattr(self, '_frequencies'):
            raise AttributeError("frequencies referenced before it was set.")
        return self._frequencies
    
    @frequencies.setter
    def frequencies(self, value):
        """
        Setter for the frequencies to which the data created here applies.
        
        value: non-empty 1D numpy.ndarray
        """
        if type(value) in sequence_types:
            value = np.array(value)
            if value.ndim == 1:
                if value.size > 0:
                    self._frequencies = value
                else:
                    raise ValueError("frequencies was set to an empty array.")
            else:
                raise ValueError("frequencies was set to a numpy.ndarray " +\
                    "of more than 1 dimension.")
        else:
            raise TypeError("frequencies was set to a non-sequence.")
    
    @property
    def nfrequencies(self):
        """
        Property storing the integer number of frequencies simulated by this
        DriftscanSetCreator.
        """
        if not hasattr(self, '_nfrequencies'):
            self._nfrequencies = len(self.frequencies)
        return self._nfrequencies
    
    @property
    def file_name(self):
        """
        Property storing the name of the hdf5 file in which to save the data
        generated by this object.
        """
        if not hasattr(self, '_file_name'):
            raise AttributeError("file_name referenced before it was set.")
        return self._file_name
    
    @file_name.setter
    def file_name(self, value):
        """
        Setter for the name of the hdf5 file in which to save the data
        generated by this object.
        
        value: string name of hdf5 file, which may or may not exist
        """
        if isinstance(value, basestring):
            self._file_name = value
        else:
            raise TypeError("file_name was set to a non-string.")
    
    @property
    def observatory(self):
        """
        Property storing the GroundObservatory object describing the location
        and orientation of the observatory on Earth.
        """
        if not hasattr(self, '_observatory'):
            raise AttributeError("observatory referenced before it was set.")
        return self._observatory
    
    @observatory.setter
    def observatory(self, value):
        """
        Setter for the GroundObservatory object describing the location and
        orientation of the observatory on Earth.
        
        value: a GroundObservatory object
        """
        if isinstance(value, GroundObservatory):
            self._observatory = value
        else:
            raise TypeError("observatory was set to a " +\
                "non-GroundObservatory object.")
    
    @property
    def beam_function(self):
        """
        Property storing a function which generates the beams used to create
        the set of foreground curves.
        """
        if not hasattr(self, '_beam_function'):
            raise AttributeError("beam_function referenced before it was set.")
        return self._beam_function
    
    @beam_function.setter
    def beam_function(self, value):
        """
        Setter for the function which generates beams used to create the set of
        foreground curves.
        
        value: either a sequence of Beam objects or a function which, when
               given an integer satisfying 0<=i<nbeams, yields a Beam object
        """
        if type(value) in sequence_types:
            self._beam_function = (lambda index: value[index])
            self._nbeams = len(value)
        else:
            self._beam_function = value
    
    @property
    def nbeams(self):
        """
        Property storing the integer number of beams to use.
        """
        if not hasattr(self, '_nbeams'):
            raise AttributeError("nbeams referenced before it was set.")
        return self._nbeams
    
    @nbeams.setter
    def nbeams(self, value):
        """
        Setter for the number of beams to use.
        
        value: a positive integer (or None if beam_function is set to an array)
        """
        if value is None:
            pass
        elif isinstance(value, int):
            if value > 0:
                self._nbeams = value
            else:
                raise ValueError("nbeams was set to a non-positive integer.")
        else:
            raise TypeError("nbeams was set to a non-int.")
    
    @property
    def maps_function(self):
        """
        Property storing a function which generates the sky maps used to create
        the set of foreground curves.
        """
        if not hasattr(self, '_maps_function'):
            raise AttributeError("maps_function referenced before it was set.")
        return self._maps_function
    
    @maps_function.setter
    def maps_function(self, value):
        """
        Setter for the function which generates sky maps used to create the set
        of foreground curves.
        
        value: either a sequence of 2D numpy.ndarray objects or a function
               which, when given an integer satisfying 0<=i<nmaps, yields a
               2D numpy.ndarray (nfreq, npix)
        """
        if type(value) in sequence_types:
            self._maps_function = (lambda index: value[index])
            self._nmaps = len(value)
        else:
            self._maps_function = value
    
    @property
    def nmaps(self):
        """
        Property storing the integer number of sky maps to use.
        """
        if not hasattr(self, '_nmaps'):
            raise AttributeError("nmaps referenced before it was set.")
        return self._nmaps
    
    @nmaps.setter
    def nmaps(self, value):
        """
        Setter for the number of sky maps to use.
        
        value: a positive integer (or None if maps_function is set to an array)
        """
        if value is None:
            pass
        elif isinstance(value, int):
            if value > 0:
                self._nmaps = value
            else:
                raise ValueError("nmaps was set to a non-positive integer.")
        else:
            raise TypeError("nmaps was set to a non-int.")
    
    @property
    def nlst_intervals(self):
        """
        Property storing the integer number of LST intervals for which to
        provide spectra for each beam and Galaxy map.
        """
        raise NotImplementedError("The nlst_intervals property must be set " +\
            "by a subclass of DriftscanSetCreator and the " +\
            "DriftscanSetCreator class should never be directly instantiated.")
    
    def simulate_single_spectrum(self, beam, maps, ilst, **kwargs):
        """
        Simulates single spectrum for this driftscan set.
        
        beam: the beam to use in making this spectrum
        maps: the sequence of galaxy maps to use in making this spectrum
        ilst: index of the LST interval to simulate, must be a non-negative
              integer less than nlst_intervals
        kwargs: extra keyword arguments
        
        returns: single 1D numpy.ndarray of length self.nfrequencies
        """
        raise NotImplementedError("simulate_single_spectrum must be " +\
            "implemented by every subclass of DriftscanSetCreator and " +\
            "DriftscanSetCreator should never be directly instantiated.")
    
    def generate(self, beam_args=None, beam_kwargs=None, maps_args=None,\
        maps_kwargs=None, **kwargs):
        """
        Generates (or continues generating) convolutions for a set of Driftscan
        style foregrounds. These curves are saved in the hdf5 file at file_name
        as they are generated.
        
        beam_args: list of lists of positional arguments to pass to
                   beam_function
        beam_kwargs: list of dictionaries of keyword arguments to pass to
                     beam_function
        maps_args: list of lists of positional arguments to pass to
                   maps_function
        maps_kwargs: list of dictionaries of keyword arguments to pass to
                     maps_function
        **kwargs: dictionary of keyword arguments to pass to
                  simulate_single_spectrum function of this class.
        """
        if beam_args is None:
            beam_args = [[]] * self.nbeams
        if beam_kwargs is None:
            beam_kwargs = [{}] * self.nbeams
        if maps_args is None:
            maps_args = [[]] * self.nmaps
        if maps_kwargs is None:
            maps_kwargs = [{}] * self.nmaps
        completed = self.file.attrs['next_index']
        try:
            for ibeam in range(self.nbeams):
                if (ibeam * self.nmaps) < completed:
                    continue
                beam = self.beam_function(ibeam, *beam_args[ibeam],\
                    **beam_kwargs[ibeam])
                for imaps in range(self.nmaps):
                    if ((ibeam * self.nmaps) + imaps) < completed:
                        continue
                    maps = self.maps_function(imaps, *maps_args[imaps],\
                        **maps_kwargs[imaps])
                    convolution =\
                        np.ndarray((self.nlst_intervals, maps.shape[0]))
                    for ilst in range(self.nlst_intervals):
                         convolution[ilst,:] = self.simulate_single_spectrum(\
                             beam, maps, ilst, **kwargs)
                    self.file.create_dataset('beam_{0:d}_maps_{1:d}'.format(\
                        ibeam, imaps), data=convolution)
                    completed += 1
                    self.file.attrs['next_index'] = completed
                    if self.verbose:
                        print("Finished convolution #{0:d} at {1!s}.".format(\
                            completed, time.ctime()))
        except KeyboardInterrupt:
            if self.verbose:
                print("Stopping convolutions at {!s}.".format(time.ctime()))
        self.close()
    
    @property
    def file(self):
        """
        Property storing the h5py File object in which the data generated by
        this object will be saved.
        """
        if not hasattr(self, '_file'):
            if os.path.exists(self.file_name):
                self._file = h5py.File(self.file_name, 'r+')
            else:
                self._file = h5py.File(self.file_name, 'w')
                self._file.attrs['next_index'] = 0
        return self._file
    
    def get_training_set(self, flatten_identifiers=False,\
        flatten_curves=False):
        """
        Gets the (assumed already generated) training set in the file of this
        DriftscanSetCreator.
        
        flatten_identifiers: boolean determining whether beam and map axis
                             should be combined into one (maps is the "inner"
                             axis)
        flatten_curves: boolean determining whether LST and frequency axis
                        should be combined into one (frequency is the "inner"
                        axis)
        
        returns: numpy.ndarray whose shape is (identifier_shape + curve_shape)
                 where identifier_shape is (nbeams, nmaps) if
                 flatten_identifiers is False and (nbeams*nmaps,) if
                 flatten_curves is True and curve_shape is
                 (nlst_intervals, nfreqs) if flatten_curves if False and
                 (nlst_intervals*nfreqs,) if flatten_curves is True
                  
        """
        training_set = np.ndarray((self.nbeams, self.nmaps,\
            self.nlst_intervals, self.nfrequencies))
        for ibeam in range(self.nbeams):
            for imaps in range(self.nmaps):
                 dataset_name = 'beam_{0:d}_maps_{1:d}'.format(ibeam, imaps)
                 training_set[ibeam,imaps,:,:] = self.file[dataset_name].value
        self.close()
        if flatten_identifiers:
            training_set =\
                np.reshape(training_set, (-1,) + training_set.shape[-2:])
        if flatten_curves:
            training_set =\
                np.reshape(training_set, training_set.shape[:-2] + (-1,))
        return training_set
    
    @staticmethod
    def load_training_set(file_name, flatten_identifiers=False,\
        flatten_curves=False):
        """
        Loads a training set from the DriftscanSetCreator which was saved to
        the given file name.
        
        file_name: the file in which a DriftscanSetCreator was saved
        flatten_identifiers: boolean determining whether beam and map axis
                             should be combined into one (maps is the "inner"
                             axis)
        flatten_curves: boolean determining whether LST and frequency axis
                        should be combined into one (frequency is the "inner"
                        axis)
        
        returns: numpy.ndarray whose shape is (identifier_shape + curve_shape)
                 where identifier_shape is (nbeams, nmaps) if
                 flatten_identifiers is False and (nbeams*nmaps,) if
                 flatten_curves is True and curve_shape is
                 (nlst_intervals, nfreqs) if flatten_curves if False and
                 (nlst_intervals*nfreqs,) if flatten_curves is True
        """
        hdf5_file = h5py.File(file_name, 'r')
        (nlst, nfreq) = hdf5_file['beam_0_maps_0'].shape
        nbeams = 0
        while 'beam_{:d}_maps_0'.format(nbeams) in hdf5_file:
            nbeams += 1
        nmaps = 0
        while 'beam_0_maps_{:d}'.format(nmaps) in hdf5_file:
            nmaps += 1
        training_set = np.ndarray((nbeams, nmaps, nlst, nfreq))
        for ibeam in range(nbeams):
            for imaps in range(nmaps):
                training_set[ibeam,imaps,:,:] = hdf5_file[].value
        hdf5_file.close()
        if flatten_identifiers:
            training_set =\
                np.reshape(training_set, (-1,) + training_set.shape[-2:])
        if flatten_curves:
            training_set =\
                np.reshape(training_set, training_set.shape[:-2] + (-1,))
        return training_set
    
    def close(self):
        """
        Closes the file containing the driftscan spectra made by this object.
        """
        if hasattr(self, '_file'):
            self.file.close()
            del self._file

